学习笔记
**hash表**

```text
1.很难保证每一个"键"通过哈希函数转换对应不同的索引 ---> 产出hash冲突
2.空间换时间 O(1) ? 
```
**hash函数的设计原则**

```text
1.一致性:如果 a=b 则hash(a) == hash(b)
2.高效性:计算高效简便
3.均匀性:哈希值均匀分布

```


**HashMap**
```text
1.基于hash表实现了map接口,允许key和values值都为空,线程不安全,不能保证随着时间的变化，顺序保持不变
2.初始化容量及加载因子要按实际情况设定。（一般不会改变加载因子的大小）
3.如果我们创建的HashMap对象要存储大量的数据，应该给定一个初始容量。（不然内部会一直扩容，降低性能）如果有很多个key的hash值相同，有必要让这些key值实现Comparable接口。
4.HashMap是一个线程不安全的类，如果要保证它的线程安全，应该使用方法Collections.synchronizedMap(new HashMap(...))来进行包装
5.迭代器是fail-fast,在使用hashmap集合的时候，不要使用高级for遍历来进行增加和删除操作。
6.定义初始化的容量，必须是2的倍数,默认值为16: static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16    
7.定义最大容量为： 1*2^30 
8.默认的加载因子 0.75 假设未给定初始化长度，默认16.当使用put方法添加k/v值时，超过16*0.75=12时，长度会自动扩容为原来长度的两倍，也就是16*2=32 当长度增加到32*0.75=24时，继续扩容为32*2=64
9.定义链表转换为红黑树的长度:8  static final int TREEIFY_THRESHOLD = 8; 转成红黑树的原因:链表的查询操作都是O(N)的时间复杂度,转换为红黑树结构增删改查都是O(log n)。
10.（进行删除操作时）红黑树转换为链表结构的长度值为6  static final int UNTREEIFY_THRESHOLD = 6;

```

**树**

```text
1.是一个二维数据结构
2.树有一个根节点,左子树,右子树,叶子节点.层级
3.二叉搜索树:
    3.1: 左子树上所有节点的值均小于它的根节点的值
    3.2: 右子树上所有节点的值均大于它的根节点的值
    3.3: 左、右子树也分别为二叉查找树。 
    3.4: 查询，插入,删除时间复杂度都是 O(logn)

```

